# 经典错误
1. cin>>与getline（cin,s）输入**混用**时应谨慎，参考此[博客](http://blog.csdn.net/u011421608/article/details/44591579)。<br />当我们使用cin>>输入一串字符（即使字符串中间、结尾没有任何空白符），我们最后敲击回车来完成输入，这样会在字符串最后留下一个换行符（\\n）,由于换行符的存在，getline()会不等待再次输入直接将cin>>输入后剩下的字符串直接输入到string对象s中（换行符被丢弃）。可以使用“cin.ignore()”清除以回车结束的输入缓冲区的内容,消除上一次输入对下一次输入的影响.参考此[博客](http://blog.csdn.net/wxbmelisky/article/details/48596881)。<br />`cin.ignore(a,ch);`用法：从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到a或者被抛弃的字符是ch，则cin.ignore()函数执行终止；否则，它继续等待。如果cin.ignore()不给参数，则默认参数为cin.ignore(1,EOF)，即把EOF前的1个字符清掉，没有遇到EOF就清掉一个字符然后结束，会导致不正确的结果，因为EOF是文件结束标识。
2. 
2. string对象可以相加，+是string对象可以进行的操作，但字符串字面值与string是不同的类型因此必须确保每个加法运算符两侧的对象至少有一个是string。
3. 不要使用`using namespace std;`这样很容易在复杂程序中因为起名字而出错。
4. 在一些老式的编译器中如果vector的元素还是vector，必须在外层vector对象的右尖括号和其元素类型之间加一个空格，如`vector<vector<int> >`;但是c++11标准中不需要再加该空格。
5. 初始化的几种例外情况：
    * 拷贝初始化（使用=），只能提供一个初始值。
    * 如果提供的是一个类内初始值，则只能使用拷贝初始化或者花括号的形式进行初始化。
    * 如果提供的是初始元素值的列表则只能把初始值放入花括号而不是圆括号。这是因为有时候初始元素值是整数而且只有一个时，可能产生歧义（到底是元素数量还是初始值呢？）
      * `vector<string> v1{"a","an","the"}; //列表初始化`
      * `vector<string> v1("a","an","the"); //错误`
      * `vector<int> v1(10);  //v1有10个元素，每个都是0`
      * `vector<int> v2{10};  //v2有1个元素，值为10`
    * 对于vector来说，如果只提供了元素数量没有设定初始值，则只能使用直接初始化。
6. 范围for语句体内不应改变其所遍历的序列的大小。
7. vector对象（以及string对象）下标只能用来访问已存在的元素，不能用于添加元素。
8. auto和decltype的异同：
    1. `auto item = val1+val2;  //item初始化为val1和val2相加的结果，其类型也由该结果确定`
        * auto一般忽略顶层const，保留底层const
    2. `decltype(表达式) a;//把a设为表达式的数据类型`
        * 保留顶层const和引用
        * 如果表达式有解引用操作，则得到引用类型
        * `decltype((variable))`注意是双层括号，其结果永远是引用
    3. 在遇见数组时，<br />
        ```c++
        int a[]={1,2,3,4,5,6,7,8,9,10};
        auto ia = a;//ia是指向数组a的指针
        decltype(a) ia2={1,2,3,4,5,6,7,8,9,10}; //ia2是一个含有10个整数的数组
        ```
    2. ``
