# C++ primer学习笔记
[Toc]
## 学习进度
* 目前已学习至p104
* 跳过的部分
  * 第一章，p13到第一章结束
  * 练习2.33到2.42（p62到p68）
  * 练习3.1到练习3.33
## 学习笔记
### 思路
1. 将0到15的十进制数转换成十六进制，可以使用一个`const string hexdigits = "0123456789ABCDEF"`的**常量**字符串，这样通过`hexdigits[十进制数]`就可以将十进制数转化为十六进制数。类似的，还有使用vector或者数组存各个成绩段人数。
2. 无论任何时候，都要**确保下标的合法性**。
    * 尽量使用范围for语句（使用时不能改变元素数量）
    * 字符串下标应大于或等于0并且小于字符串的size()值。一种方法是将下标总是设置为`string::size_type`类型，由于是无符号数，可以确保不小于0，只需保证下标小于size()就行。类似的，还有`vector<ElemType>::size_type`。
3.
***
### 经典错误

1. cin>>与getline（cin,s）输入**混用**时应谨慎，参考此[博客](http://blog.csdn.net/u011421608/article/details/44591579)。<br />当我们使用cin>>输入一串字符（即使字符串中间、结尾没有任何空白符），我们最后敲击回车来完成输入，这样会在字符串最后留下一个换行符（\\n）,由于换行符的存在，getline()会不等待再次输入直接将cin>>输入后剩下的字符串直接输入到string对象s中（换行符被丢弃）。可以使用“cin.ignore()”清除以回车结束的输入缓冲区的内容,消除上一次输入对下一次输入的影响.参考此[博客](http://blog.csdn.net/wxbmelisky/article/details/48596881)。<br />`cin.ignore(a,ch);`用法：从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到a或者被抛弃的字符是ch，则cin.ignore()函数执行终止；否则，它继续等待。如果cin.ignore()不给参数，则默认参数为cin.ignore(1,EOF)，即把EOF前的1个字符清掉，没有遇到EOF就清掉一个字符然后结束，会导致不正确的结果，因为EOF是文件结束标识。
2. string对象可以相加，+是string对象可以进行的操作，但字符串字面值与string是不同的类型因此必须确保每个加法运算符两侧的对象至少有一个是string。
3. 不要使用`using namespace std;`这样很容易在复杂程序中因为起名字而出错。
4. 在一些老式的编译器中如果vector的元素还是vector，必须在外层vector对象的右尖括号和其元素类型之间加一个空格，如`vector<vector<int> >`;但是c++11标准中不需要再加该空格。
5. 初始化的几种例外情况：
    * 拷贝初始化（使用=），只能提供一个初始值。
    * 如果提供的是一个类内初始值，则只能使用拷贝初始化或者花括号的形式进行初始化。
    * 如果提供的是初始元素值的列表则只能把初始值放入花括号而不是圆括号。这是因为有时候初始元素值是整数而且只有一个时，可能产生歧义（到底是元素数量还是初始值呢？）
      * `vector<string> v1{"a","an","the"}; //列表初始化`
      * `vector<string> v1("a","an","the"); //错误`
      * `vector<int> v1(10);  //v1有10个元素，每个都是0`
      * `vector<int> v2{10};  //v2有1个元素，值为10`
    * 对于vector来说，如果只提供了元素数量没有设定初始值，则只能使用直接初始化。
6. 范围for语句体内不应改变其所遍历的序列的大小。
7. vector对象（以及string对象）下标只能用来访问已存在的元素，不能用于添加元素。
8. auto和decltype的异同：
    1. `auto item = val1+val2;  //item初始化为val1和val2相加的结果，其类型也由该结果确定`
        * auto一般忽略顶层const，保留底层const
    2. `decltype(表达式) a;//把a设为表达式的数据类型`
        * 保留顶层const和引用
        * 如果表达式有解引用操作，则得到引用类型
        * `decltype((variable))`注意是双层括号，其结果永远是引用
    3. 在遇见数组时，<br />
        ```c++
        int a[]={1,2,3,4,5,6,7,8,9,10};
        auto ia = a;//ia是指向数组a的指针
        decltype(a) ia2={1,2,3,4,5,6,7,8,9,10}; //ia2是一个含有10个整数的数组
        ```
    2. ``
***
### 第二章 变量和基本类型
#### 2.1 *基本内置类型*
* **数据类型**决定了程序中数据和操作的意义。
* **基本内置类型**：算术类型（arithmetic type）和空类型（void type）
* **算术类型**：整形（integral type，包括字符和布尔型在内）和浮点型
#### 2.3 *复合类型*（compoud type）
1.**引用**（reference）
 * **引用**（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。
 * 通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。
  ```c++
    int i = 1024;
    int &d1 = i;        //d1指向i
    int &d2;            //错误，引用必须被初始化
    auto &h = 42;       //错误，不能为非常量引用绑定字面值
    const auto &j =42;  //正确，可以为常量引用绑定字面值
  ```
  ***
  ***
## 不懂的部分
1. 为什么给无符号和有符号数赋超过他们范围的值的结果却相差很大，一个变成取模后的余数，一个是未定义？书p33
2.	为什么如果把int的尺寸看做是一个固定不变的已知值，则这样的程序就称作不可移植的（nonportable）
3.	在函数体内部，如果试图初始化一个由extern关键字标记的变量，将会引发错误。？？？不应该是变成定义了吗？？？p41
4.	c++各个操作符替代名所指的操作符是什么？？
5.	对于const的引用的例外情况？？p55
6.	一个constexpr指针的初始值必须是nullptr或0，或者是存储于某一个固定地址中的对象？？p59
7.	auto定义的变量必须有初始值？p61<br />  答：因为auto是靠初始值来确定具体类型的。
8.	decltype和auto在处理顶层const时到底哪里不同？p63
9.  为什么类内初始化时不要使用圆括号？<br />  答：因为会引起歧义？？？？
10.	头文件保护符？防止重复包含的意义和作用？？p68
11.	string的直接初始化和拷贝初始化的异同，区分的意义？？p78
12.	string可不可以使用字符串字面值赋值？？p80<br />答：可以
13. string类是不是一定以'\\0'结尾？ <br />不是。c风格的字符串才用这个结尾，string不用
14. p62疑问
15. 迭代器会想数组指针一样越位吗？
16. 可以用`vector<auto>`？？
17. `int a[10}={1};`其中的元素的值各是多少？
18. p145
19. switch中default是否可以灵活的选择位置？？？如
    ```c++
    sitch(i){
      case 1:
          break;
      case 2:
          break;
      default:
      //无break
      case 3:
          break;
    }
    ```
20. 
