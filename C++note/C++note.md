# C++ primer学习笔记
## 学习进度
* 目前已学习至p81
* 跳过的部分
  * 第一章，p13到第一章结束
  * 练习2.33到2.42（p62到p68）
  * 练习3.1到练习3.5
## 学习笔记
### 经典错误

1. cin>>与getline（cin,s）输入**混用**时应谨慎，参考此[博客](http://blog.csdn.net/u011421608/article/details/44591579)。
  当我们使用cin>>输入一串字符（即使字符串中间、结尾没有任何空白符），我们最后敲击回车来完成输入，这样会在字符串最后留下一个换行符（\\n）,由于换行符的存在，getline()会不等待再次输入直接将cin>>输入后剩下的字符串直接输入到string对象s中（换行符被丢弃）。可以使用“cin.ignore()”清除以回车结束的输入缓冲区的内容,消除上一次输入对下一次输入的影响.参考此[博客](http://blog.csdn.net/wxbmelisky/article/details/48596881)。
  `cin.ignore(a,ch);`用法：从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到a或者被抛弃的字符是ch，则cin.ignore()函数执行终止；否则，它继续等待。如果cin.ignore()不给参数，则默认参数为cin.ignore(1,EOF)，即把EOF前的1个字符清掉，没有遇到EOF就清掉一个字符然后结束，会导致不正确的结果，因为EOF是文件结束标识。
2. string对象可以相加，+是string对象可以进行的操作，但字符串字面值与string是不同的类型因此必须确保每个加法运算符两侧的对象至少有一个是string。
3. 不要使用`using namespace std;`这样很容易在复杂程序中因为起名字而出错。
***
### 第二章 变量和基本类型
#### 2.1 *基本内置类型*
* **数据类型**决定了程序中数据和操作的意义。
* **基本内置类型**：算术类型（arithmetic type）和空类型（void type）
* **算术类型**：整形（integral type，包括字符和布尔型在内）和浮点型
#### 2.3 *复合类型*（compoud type）
1.**引用**（reference）
 * **引用**（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。
 * 通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。
  ```c++
    int i = 1024;
    int &d1 = i;        //d1指向i
    int &d2;            //错误，引用必须被初始化
    auto &h = 42;       //错误，不能为非常量引用绑定字面值
    const auto &j =42;  //正确，可以为常量引用绑定字面值
  ```
  ***
  ***
## 不懂的部分
1. 为什么给无符号和有符号数赋超过他们范围的值的结果却相差很大，一个变成取模后的余数，一个是未定义？书p33
2.	为什么如果把int的尺寸看做是一个固定不变的已知值，则这样的程序就称作不可移植的（nonportable）
3.	在函数体内部，如果试图初始化一个由extern关键字标记的变量，将会引发错误。？？？不应该是变成定义了吗？？？p41
4.	c++各个操作符替代名所指的操作符是什么？？
5.	对于const的引用的例外情况？？p55
6.	一个constexpr指针的初始值必须是nullptr或0，或者是存储于某一个固定地址中的对象？？p59
7.	auto定义的变量必须有初始值？p61
    答：因为auto是靠初始值来确定具体类型的。
8.	decltype和auto在处理顶层const时到底哪里不同？p63
9.  为什么类内初始化时不要使用圆括号？
    答：因为会引起歧义？？？？
10.	头文件保护符？防止重复包含的意义和作用？？p68
11.	string的直接初始化和拷贝初始化的异同，区分的意义？？p78
12.	string可不可以使用字符串字面值赋值？？p80
    可以
